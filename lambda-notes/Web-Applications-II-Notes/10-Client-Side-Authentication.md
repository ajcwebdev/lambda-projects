Many services require the client (React app) to provide proof it’s authenticated. The server can issue a JSON Web Token as the authentication token in exchange for correct login credentials. Servers usually don’t remember anything about us after each interaction. Clients need a reminder after every request. This is commonly done automatically with cookies, small pieces of data generated by the browser to store state information. Modern web services dealing with JSON data often use JWTs issued by the server and stored on the client-side using local storage or session storage. The server can tell the client it issued the token or read the token and make decisions for data transfer based on the client’s permission.

A common pattern is a login endpoint taking a payload of `username` and `password`. If the credentials are known the server responds with a fresh JWT. It’s then the application’s responsibility to add an `Authorization: <token>` header to every request to be allowed access to protected resources that require authentication. We are going to create an Axios configuration that attaches an `Authorization: <token>` header to requests. We will create a new file called `axiosAuth.js`. Whenever the application needs to exchange data with a protected endpoint, it imports this module, instead of the usual `import axios from "axios";`.

```javascript
import axios from 'axios';

export const axiosWithAuth =() => {
    const token = localStorage.getItem('token');

    return axios.create({
        headers: {
            Authorization: token,
        },
    });
};
```

```javascript
Authorization: `Bearer ${token}`,
```

After the user authenticates (logs in), the server returns the token. Your application needs to save the returned token (the permissions) to `localStorage` so that the above `axiosWithAuth` module can grab it for other calls that require the Authorization header.

```javascript
const login = () => {
  axios.post('endpoint/here', userCredentials)
    .then(res => {
      localStorage.setItem('token', res.data.token);
      props.history.push('/dashboard');
    }
}
```

Now with the token we can do an AJAX request to an endpoint using the `axiosWithAuth.js` module.

```javascript
  import { axiosWithAuth } from '../../path/to/axiosAuth.js';
  // etc
  axiosWithAuth().get('endpoint/path/here').then(data => /* do something with the data */);
```

If you inspect the request on the Network tab in Chrome Devtools, you should see `Authorization: eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ` among the request headers. We can improve our custom Axios configuration using the library `axios-retry`. It automatically retries the request three times if there are errors or timeouts. Most web apps have some sort of authentication system. We want to protect any routes in our app from being rendered if the user is not authenticated with a token from the server.

Protected routes should only render with authentication. Normally, the client will make a login request, sending the server the user’s username and password. Then, the server will check those credentials against the database, and if it can authenticate the user, it will return a token. Once we have this token, we can add two layers of protection to our app. One uses protected routes, and the other sends an authentication header with our API calls (as we learned in the above objective).

We will use React Router components and build a custom `<PrivateRoute />` component to protect the route. In our `App` component, let’s add a couple of public routes and a couple of links:

```javascript
function App() {
  return (
    <div>
      <ul>
        <li>
          <Link to="/public">Public Page</Link>
        </li>
        <li>
          <Link to="/protected">Protected Page</Link>
        </li>
      </ul>
      <Route path="/public" component={Public} />
      <Route path="/login" component={Login} />
    </div>
  );
}
```

Anyone can click on the “Public Page” link, but if they click on the “Protected Page” link without authorization they will be routed to the login page instead. Next step will be to add a `<PrivateRoute />` route:

```javascript
<Route path="/public" component={Public}/>
<Route path="/login" component={Login}/>
<PrivateRoute path='/protected' component={Protected} />
```

Here are the requirements for our PrivateRoute component:

* It has the same API as `<Route />`.
* It renders a `<Route />` and passes all the props through to it.
* It checks if the user is authenticated, if they are, it renders the “component” prop. If not, it redirects the user to /login.

```javascript
// Requirement 1.
// It has the same API as `<Route />`

const PrivateRoute = ({ component: Component, ...rest }) => (

)
```

This code means that the component can accept a component Prop, just like `<Route />` does, and take any other prop that gets passed into it by spreading in `...rest`.

```javascript
// Requirement 2.
// It renders a `<Route />` and passes all the props through to it.

const PrivateRoute = ({ component: Component, ...rest }) => (
  <Route {...rest} render={} />
)
```

We are passing in all of the props passed to `<PrivateRoute />` in the App component.

```javascript
// Requirement 3.
// It checks if the user is authenticated, if they are,
// it renders the "component" prop. If not, it redirects
// the user to /login.

const PrivateRoute = ({ component: Component, ...rest }) => (
  <Route
    {...rest}
    render={props =>
      localStorage.getItem("token") ? (
        <Component {...props} />
      ) : (
        <Redirect to="/login" />
      )
    }
  />
);
```

The `<Redirect />` component is from React Router. It redirects the app to the supplied route. At this point, you can see the PrivateRoute component in action if you try to click on the Protected Page link. You should be redirected to “/login” instead of being taken to the “/protected” page. Our login page is going to be a form that takes in a user’s credentials, calls the login endpoint with a `POST` request, and then redirects the user to the protected route when the login API call returns.

```javascript
import React, { useState } from 'react';
import { axiosWithAuth } from '../path/to/module';

const Login = (props) => {
 const [credentials, setCredentials] = useState({});

  const login = e => {
    e.preventDefault();
    axiosWithAuth().post('login/endpoint', credentials)
      .then(res => {
        localStorage.setItem('token', res.data.token);
        this.props.history.push('/');
      })
  }

  const handleChange = e => {
      setCredentials: {
        ...credentials,
        [e.target.name]: e.target.value,
      }
  }

    return (
      <div>
        <form onSubmit={this.login}>
          <input
            type="text"
            name="username"
            value={credentials.username}
            onChange={this.handleChange}
          />
          <input
            type="password"
            name="password"
            value={credentials.password}
            onChange={this.handleChange}
          />
          <button>Log in</button>
        </form>
      </div>
    )
}

export default Login;
```
